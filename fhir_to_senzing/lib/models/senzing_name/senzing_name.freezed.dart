// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'senzing_name.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SenzingName _$SenzingNameFromJson(Map<String, dynamic> json) {
  return _SenzingName.fromJson(json);
}

/// @nodoc
class _$SenzingNameTearOff {
  const _$SenzingNameTearOff();

  _SenzingName call(
      {@JsonKey(name: 'NAME_TYPE') String? nameType,
      @JsonKey(name: 'NAME_FULL') String? nameFull,
      @JsonKey(name: 'NAME_ORG') String? nameOrg,
      @JsonKey(name: 'NAME_LAST') String? nameLast,
      @JsonKey(name: 'NAME_FIRST') String? nameFirst,
      @JsonKey(name: 'NAME_MIDDLE') String? nameMiddle,
      @JsonKey(name: 'NAME_PREFIX') String? namePrefix,
      @JsonKey(name: 'NAME_SUFFIX') String? nameSuffix}) {
    return _SenzingName(
      nameType: nameType,
      nameFull: nameFull,
      nameOrg: nameOrg,
      nameLast: nameLast,
      nameFirst: nameFirst,
      nameMiddle: nameMiddle,
      namePrefix: namePrefix,
      nameSuffix: nameSuffix,
    );
  }

  SenzingName fromJson(Map<String, Object> json) {
    return SenzingName.fromJson(json);
  }
}

/// @nodoc
const $SenzingName = _$SenzingNameTearOff();

/// @nodoc
mixin _$SenzingName {
  @JsonKey(name: 'NAME_TYPE')
  String? get nameType => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_FULL')
  String? get nameFull => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_ORG')
  String? get nameOrg => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_LAST')
  String? get nameLast => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_FIRST')
  String? get nameFirst => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_MIDDLE')
  String? get nameMiddle => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_PREFIX')
  String? get namePrefix => throw _privateConstructorUsedError;
  @JsonKey(name: 'NAME_SUFFIX')
  String? get nameSuffix => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SenzingNameCopyWith<SenzingName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SenzingNameCopyWith<$Res> {
  factory $SenzingNameCopyWith(
          SenzingName value, $Res Function(SenzingName) then) =
      _$SenzingNameCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'NAME_TYPE') String? nameType,
      @JsonKey(name: 'NAME_FULL') String? nameFull,
      @JsonKey(name: 'NAME_ORG') String? nameOrg,
      @JsonKey(name: 'NAME_LAST') String? nameLast,
      @JsonKey(name: 'NAME_FIRST') String? nameFirst,
      @JsonKey(name: 'NAME_MIDDLE') String? nameMiddle,
      @JsonKey(name: 'NAME_PREFIX') String? namePrefix,
      @JsonKey(name: 'NAME_SUFFIX') String? nameSuffix});
}

/// @nodoc
class _$SenzingNameCopyWithImpl<$Res> implements $SenzingNameCopyWith<$Res> {
  _$SenzingNameCopyWithImpl(this._value, this._then);

  final SenzingName _value;
  // ignore: unused_field
  final $Res Function(SenzingName) _then;

  @override
  $Res call({
    Object? nameType = freezed,
    Object? nameFull = freezed,
    Object? nameOrg = freezed,
    Object? nameLast = freezed,
    Object? nameFirst = freezed,
    Object? nameMiddle = freezed,
    Object? namePrefix = freezed,
    Object? nameSuffix = freezed,
  }) {
    return _then(_value.copyWith(
      nameType: nameType == freezed
          ? _value.nameType
          : nameType // ignore: cast_nullable_to_non_nullable
              as String?,
      nameFull: nameFull == freezed
          ? _value.nameFull
          : nameFull // ignore: cast_nullable_to_non_nullable
              as String?,
      nameOrg: nameOrg == freezed
          ? _value.nameOrg
          : nameOrg // ignore: cast_nullable_to_non_nullable
              as String?,
      nameLast: nameLast == freezed
          ? _value.nameLast
          : nameLast // ignore: cast_nullable_to_non_nullable
              as String?,
      nameFirst: nameFirst == freezed
          ? _value.nameFirst
          : nameFirst // ignore: cast_nullable_to_non_nullable
              as String?,
      nameMiddle: nameMiddle == freezed
          ? _value.nameMiddle
          : nameMiddle // ignore: cast_nullable_to_non_nullable
              as String?,
      namePrefix: namePrefix == freezed
          ? _value.namePrefix
          : namePrefix // ignore: cast_nullable_to_non_nullable
              as String?,
      nameSuffix: nameSuffix == freezed
          ? _value.nameSuffix
          : nameSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$SenzingNameCopyWith<$Res>
    implements $SenzingNameCopyWith<$Res> {
  factory _$SenzingNameCopyWith(
          _SenzingName value, $Res Function(_SenzingName) then) =
      __$SenzingNameCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'NAME_TYPE') String? nameType,
      @JsonKey(name: 'NAME_FULL') String? nameFull,
      @JsonKey(name: 'NAME_ORG') String? nameOrg,
      @JsonKey(name: 'NAME_LAST') String? nameLast,
      @JsonKey(name: 'NAME_FIRST') String? nameFirst,
      @JsonKey(name: 'NAME_MIDDLE') String? nameMiddle,
      @JsonKey(name: 'NAME_PREFIX') String? namePrefix,
      @JsonKey(name: 'NAME_SUFFIX') String? nameSuffix});
}

/// @nodoc
class __$SenzingNameCopyWithImpl<$Res> extends _$SenzingNameCopyWithImpl<$Res>
    implements _$SenzingNameCopyWith<$Res> {
  __$SenzingNameCopyWithImpl(
      _SenzingName _value, $Res Function(_SenzingName) _then)
      : super(_value, (v) => _then(v as _SenzingName));

  @override
  _SenzingName get _value => super._value as _SenzingName;

  @override
  $Res call({
    Object? nameType = freezed,
    Object? nameFull = freezed,
    Object? nameOrg = freezed,
    Object? nameLast = freezed,
    Object? nameFirst = freezed,
    Object? nameMiddle = freezed,
    Object? namePrefix = freezed,
    Object? nameSuffix = freezed,
  }) {
    return _then(_SenzingName(
      nameType: nameType == freezed
          ? _value.nameType
          : nameType // ignore: cast_nullable_to_non_nullable
              as String?,
      nameFull: nameFull == freezed
          ? _value.nameFull
          : nameFull // ignore: cast_nullable_to_non_nullable
              as String?,
      nameOrg: nameOrg == freezed
          ? _value.nameOrg
          : nameOrg // ignore: cast_nullable_to_non_nullable
              as String?,
      nameLast: nameLast == freezed
          ? _value.nameLast
          : nameLast // ignore: cast_nullable_to_non_nullable
              as String?,
      nameFirst: nameFirst == freezed
          ? _value.nameFirst
          : nameFirst // ignore: cast_nullable_to_non_nullable
              as String?,
      nameMiddle: nameMiddle == freezed
          ? _value.nameMiddle
          : nameMiddle // ignore: cast_nullable_to_non_nullable
              as String?,
      namePrefix: namePrefix == freezed
          ? _value.namePrefix
          : namePrefix // ignore: cast_nullable_to_non_nullable
              as String?,
      nameSuffix: nameSuffix == freezed
          ? _value.nameSuffix
          : nameSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SenzingName extends _SenzingName {
  _$_SenzingName(
      {@JsonKey(name: 'NAME_TYPE') this.nameType,
      @JsonKey(name: 'NAME_FULL') this.nameFull,
      @JsonKey(name: 'NAME_ORG') this.nameOrg,
      @JsonKey(name: 'NAME_LAST') this.nameLast,
      @JsonKey(name: 'NAME_FIRST') this.nameFirst,
      @JsonKey(name: 'NAME_MIDDLE') this.nameMiddle,
      @JsonKey(name: 'NAME_PREFIX') this.namePrefix,
      @JsonKey(name: 'NAME_SUFFIX') this.nameSuffix})
      : super._();

  factory _$_SenzingName.fromJson(Map<String, dynamic> json) =>
      _$_$_SenzingNameFromJson(json);

  @override
  @JsonKey(name: 'NAME_TYPE')
  final String? nameType;
  @override
  @JsonKey(name: 'NAME_FULL')
  final String? nameFull;
  @override
  @JsonKey(name: 'NAME_ORG')
  final String? nameOrg;
  @override
  @JsonKey(name: 'NAME_LAST')
  final String? nameLast;
  @override
  @JsonKey(name: 'NAME_FIRST')
  final String? nameFirst;
  @override
  @JsonKey(name: 'NAME_MIDDLE')
  final String? nameMiddle;
  @override
  @JsonKey(name: 'NAME_PREFIX')
  final String? namePrefix;
  @override
  @JsonKey(name: 'NAME_SUFFIX')
  final String? nameSuffix;

  @override
  String toString() {
    return 'SenzingName(nameType: $nameType, nameFull: $nameFull, nameOrg: $nameOrg, nameLast: $nameLast, nameFirst: $nameFirst, nameMiddle: $nameMiddle, namePrefix: $namePrefix, nameSuffix: $nameSuffix)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SenzingName &&
            (identical(other.nameType, nameType) ||
                const DeepCollectionEquality()
                    .equals(other.nameType, nameType)) &&
            (identical(other.nameFull, nameFull) ||
                const DeepCollectionEquality()
                    .equals(other.nameFull, nameFull)) &&
            (identical(other.nameOrg, nameOrg) ||
                const DeepCollectionEquality()
                    .equals(other.nameOrg, nameOrg)) &&
            (identical(other.nameLast, nameLast) ||
                const DeepCollectionEquality()
                    .equals(other.nameLast, nameLast)) &&
            (identical(other.nameFirst, nameFirst) ||
                const DeepCollectionEquality()
                    .equals(other.nameFirst, nameFirst)) &&
            (identical(other.nameMiddle, nameMiddle) ||
                const DeepCollectionEquality()
                    .equals(other.nameMiddle, nameMiddle)) &&
            (identical(other.namePrefix, namePrefix) ||
                const DeepCollectionEquality()
                    .equals(other.namePrefix, namePrefix)) &&
            (identical(other.nameSuffix, nameSuffix) ||
                const DeepCollectionEquality()
                    .equals(other.nameSuffix, nameSuffix)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(nameType) ^
      const DeepCollectionEquality().hash(nameFull) ^
      const DeepCollectionEquality().hash(nameOrg) ^
      const DeepCollectionEquality().hash(nameLast) ^
      const DeepCollectionEquality().hash(nameFirst) ^
      const DeepCollectionEquality().hash(nameMiddle) ^
      const DeepCollectionEquality().hash(namePrefix) ^
      const DeepCollectionEquality().hash(nameSuffix);

  @JsonKey(ignore: true)
  @override
  _$SenzingNameCopyWith<_SenzingName> get copyWith =>
      __$SenzingNameCopyWithImpl<_SenzingName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SenzingNameToJson(this);
  }
}

abstract class _SenzingName extends SenzingName {
  factory _SenzingName(
      {@JsonKey(name: 'NAME_TYPE') String? nameType,
      @JsonKey(name: 'NAME_FULL') String? nameFull,
      @JsonKey(name: 'NAME_ORG') String? nameOrg,
      @JsonKey(name: 'NAME_LAST') String? nameLast,
      @JsonKey(name: 'NAME_FIRST') String? nameFirst,
      @JsonKey(name: 'NAME_MIDDLE') String? nameMiddle,
      @JsonKey(name: 'NAME_PREFIX') String? namePrefix,
      @JsonKey(name: 'NAME_SUFFIX') String? nameSuffix}) = _$_SenzingName;
  _SenzingName._() : super._();

  factory _SenzingName.fromJson(Map<String, dynamic> json) =
      _$_SenzingName.fromJson;

  @override
  @JsonKey(name: 'NAME_TYPE')
  String? get nameType => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_FULL')
  String? get nameFull => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_ORG')
  String? get nameOrg => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_LAST')
  String? get nameLast => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_FIRST')
  String? get nameFirst => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_MIDDLE')
  String? get nameMiddle => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_PREFIX')
  String? get namePrefix => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: 'NAME_SUFFIX')
  String? get nameSuffix => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SenzingNameCopyWith<_SenzingName> get copyWith =>
      throw _privateConstructorUsedError;
}
